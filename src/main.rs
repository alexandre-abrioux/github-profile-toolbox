mod simple_icons;

use std::fs;
use yaml_rust2::yaml::Hash;
use yaml_rust2::YamlLoader;

use crate::simple_icons::color::is_relatively_light_icon_hex;
use crate::simple_icons::SimpleIcons;
use clap::Parser;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Path to the configuration file
    #[arg(short, long)]
    config: String,
    /// Path to the README file to update
    #[arg(short, long)]
    readme: String,
}

fn main() {
    let args = Args::parse();
    let contents = fs::read_to_string(&args.config).expect("Configuration file not found");
    let toolbox_markdown = generate_toolbox(&contents);
    if args.readme.is_empty() {
        print!("{}", toolbox_markdown);
        return;
    }
    update_readme(&args.readme, &toolbox_markdown);
}

fn generate_toolbox(contents: &String) -> String {
    let tools = load_yaml(&contents);
    generate_markdown(&tools)
}

fn load_yaml(contents: &String) -> Hash {
    let docs = YamlLoader::load_from_str(&contents).unwrap();
    let yaml = &docs[0];
    let tools = yaml["tools"].as_hash().unwrap();
    tools.clone()
}

fn generate_markdown(tools: &Hash) -> String {
    let mut markdown = String::new();
    markdown.push_str(&generate_header(tools));
    markdown.push_str(&generate_items(tools));
    markdown
}

fn generate_header(tools: &Hash) -> String {
    let mut header = String::new();
    header.push_str("|");
    tools.keys().for_each(|category| {
        header.push_str(category.as_str().unwrap());
        header.push_str("|");
    });
    header.push_str("\n");

    header.push_str("|");
    tools.keys().for_each(|_category| {
        header.push_str("-");
        header.push_str("|");
    });
    header.push_str("\n");

    header
}

fn generate_items(tools: &Hash) -> String {
    let lines_nb = tools.keys().fold(0, |max_tools_length, category| {
        let category_items = tools[category].as_vec().unwrap();
        if category_items.len() > max_tools_length {
            return category_items.len();
        }
        return max_tools_length;
    });

    let mut items = String::new();
    for line in 1..=lines_nb {
        items.push_str("|");
        tools.keys().for_each(|category| {
            let category_items = tools[category].as_vec().unwrap();
            if line <= category_items.len() {
                let item = &category_items[line - 1];
                items.push_str(generate_img_tag(item.as_str().unwrap()).as_str());
            }
            items.push_str("|");
        });
        items.push_str("\n");
    }
    items
}

fn generate_img_tag(slug: &str) -> String {
    let icons = &SimpleIcons::global().icons;
    let icon = icons
        .get(slug)
        .expect(format!("Could not find icon for slug {slug}").as_str());
    let title = &icon.title;
    let hex = &icon.hex;
    let background = if is_relatively_light_icon_hex(&hex) {
        "black"
    } else {
        "white"
    };
    format!("[<img align=\"left\" alt=\"{title}\" src=\"https://img.shields.io/badge/-{title}-{hex}?logo={slug}&logoColor={background}\">](#)")
}

fn update_readme(readme_path: &String, toolbox_markdown: &String) {
    let readme_content = fs::read_to_string(&readme_path).expect("Unable to read README file");
    let toolbox_section_start_bytes = readme_content
        .find("<!-- START_SECTION:toolbox -->")
        .expect("Could not find START_SECTION comment in README file");
    let toolbox_section_end_bytes = readme_content
        .find("<!-- STOP_SECTION:toolbox -->")
        .expect("Could not find STOP_SECTION comment in README file");
    let mut readme_content_updated = String::new();
    readme_content_updated.push_str(&readme_content[0..toolbox_section_start_bytes]);
    readme_content_updated.push_str("<!-- START_SECTION:toolbox -->\n");
    readme_content_updated.push_str("<!-- Generated by github-profile-toolbox GitHub action -->\n");
    readme_content_updated.push_str(&toolbox_markdown);
    readme_content_updated
        .push_str(&readme_content[toolbox_section_end_bytes..readme_content.len()]);
    fs::write(&readme_path, readme_content_updated).expect("Unable to write to README file");
}

#[cfg(test)]
mod tests {
    use crate::generate_toolbox;

    #[test]
    fn should_generate_markdown() {
        let input = "
tools:
  ides:
    - jetbrains
    - neovim
  languages:
    - javascript
    - rust";
        let markdown = generate_toolbox(&input.to_string());
        assert_eq!(
            markdown,
            "|ides|languages|
|-|-|
|[<img align=\"left\" alt=\"JetBrains\" src=\"https://img.shields.io/badge/-JetBrains-000000?logo=jetbrains&logoColor=white\">](#)|[<img align=\"left\" alt=\"JavaScript\" src=\"https://img.shields.io/badge/-JavaScript-F7DF1E?logo=javascript&logoColor=black\">](#)|
|[<img align=\"left\" alt=\"Neovim\" src=\"https://img.shields.io/badge/-Neovim-57A143?logo=neovim&logoColor=white\">](#)|[<img align=\"left\" alt=\"Rust\" src=\"https://img.shields.io/badge/-Rust-000000?logo=rust&logoColor=white\">](#)|
"
        );
    }

    #[test]
    fn should_handle_tools_with_different_number_of_items() {
        let input = "
tools:
  ides:
    - neovim
  languages:
    - javascript
    - rust";
        let markdown = generate_toolbox(&input.to_string());
        assert_eq!(
            markdown,
            "|ides|languages|
|-|-|
|[<img align=\"left\" alt=\"Neovim\" src=\"https://img.shields.io/badge/-Neovim-57A143?logo=neovim&logoColor=white\">](#)|[<img align=\"left\" alt=\"JavaScript\" src=\"https://img.shields.io/badge/-JavaScript-F7DF1E?logo=javascript&logoColor=black\">](#)|
||[<img align=\"left\" alt=\"Rust\" src=\"https://img.shields.io/badge/-Rust-000000?logo=rust&logoColor=white\">](#)|
"
        );
    }
}
