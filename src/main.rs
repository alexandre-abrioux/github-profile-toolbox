mod markdown;
mod schema;
mod simple_icons;
mod tool;

use crate::schema::Config;
use clap::Parser;
use serde_yml::from_str;
use std::fs;

#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// Path to the configuration file
    #[arg(short, long)]
    config: String,
    /// Path to the README file to update
    #[arg(short, long)]
    readme: Option<String>,
}

fn main() {
    let args = Args::parse();
    let contents = fs::read_to_string(&args.config).expect("Configuration file not found");
    let toolbox_markdown = generate_toolbox(&contents);
    let readme_path = args.readme.unwrap_or("".to_string());
    if readme_path.is_empty() {
        print!("{}", toolbox_markdown);
        return;
    }
    update_readme(&readme_path, &toolbox_markdown);
}

fn generate_toolbox(contents: &String) -> String {
    let config = load_config_yaml(&contents);
    markdown::generate_markdown(&config.tools)
}

fn load_config_yaml(contents: &String) -> Config {
    from_str(&contents).unwrap()
}

fn update_readme(readme_path: &String, toolbox_markdown: &String) {
    let readme_content = fs::read_to_string(&readme_path).expect("Unable to read README file");
    let toolbox_section_start_bytes = readme_content
        .find("<!-- START_SECTION:toolbox -->")
        .expect("Could not find START_SECTION comment in README file");
    let toolbox_section_end_bytes = readme_content
        .find("<!-- STOP_SECTION:toolbox -->")
        .expect("Could not find STOP_SECTION comment in README file");
    let mut readme_content_updated = String::new();
    readme_content_updated.push_str(&readme_content[0..toolbox_section_start_bytes]);
    readme_content_updated.push_str("<!-- START_SECTION:toolbox -->\n");
    readme_content_updated.push_str("<!-- Generated by github-profile-toolbox GitHub action -->\n");
    readme_content_updated.push_str(&toolbox_markdown);
    readme_content_updated
        .push_str(&readme_content[toolbox_section_end_bytes..readme_content.len()]);
    fs::write(&readme_path, readme_content_updated).expect("Unable to write to README file");
}

#[cfg(test)]
mod tests {
    use crate::generate_toolbox;

    #[test]
    fn should_generate_markdown() {
        let input = "
tools:
  ides:
    - jetbrains
    - neovim
  languages:
    - javascript
    - rust";
        let markdown = generate_toolbox(&input.to_string());
        assert_eq!(
            markdown,
            r###"| ides                                                                                                                        | languages                                                                                                                      |
| --------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| [<img align="left" alt="JetBrains" src="https://img.shields.io/badge/-JetBrains-000000?logoColor=white&logo=jetbrains">](#) | [<img align="left" alt="JavaScript" src="https://img.shields.io/badge/-JavaScript-F7DF1E?logoColor=black&logo=javascript">](#) |
| [<img align="left" alt="Neovim" src="https://img.shields.io/badge/-Neovim-57A143?logoColor=white&logo=neovim">](#)          | [<img align="left" alt="Rust" src="https://img.shields.io/badge/-Rust-000000?logoColor=white&logo=rust">](#)                   |
"###
        );
    }

    #[test]
    fn should_handle_tools_with_different_number_of_items() {
        let input = "
tools:
  ides:
    - neovim
  languages:
    - javascript
    - rust";
        let markdown = generate_toolbox(&input.to_string());
        assert_eq!(
            markdown,
            r#"| ides                                                                                                               | languages                                                                                                                      |
| ------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| [<img align="left" alt="Neovim" src="https://img.shields.io/badge/-Neovim-57A143?logoColor=white&logo=neovim">](#) | [<img align="left" alt="JavaScript" src="https://img.shields.io/badge/-JavaScript-F7DF1E?logoColor=black&logo=javascript">](#) |
|                                                                                                                    | [<img align="left" alt="Rust" src="https://img.shields.io/badge/-Rust-000000?logoColor=white&logo=rust">](#)                   |
"#
        );
    }

    #[test]
    fn should_handle_tools_with_custom_config() {
        let input = r##"
tools:
  ides:
    - label: VSCode
      color: 29a9f2
    - label: VSCode
      color: "#29a9f2"
    - label: RustRover
      icon: jetbrains
    - label: RustRover
      icon: jetbrains
      color: feab02
"##;
        let markdown = generate_toolbox(&input.to_string());
        assert_eq!(
            markdown,
            r#"| ides                                                                                                                        |
| --------------------------------------------------------------------------------------------------------------------------- |
| [<img align="left" alt="VSCode" src="https://img.shields.io/badge/-VSCode-29a9f2?logoColor=white">](#)                      |
| [<img align="left" alt="VSCode" src="https://img.shields.io/badge/-VSCode-29a9f2?logoColor=white">](#)                      |
| [<img align="left" alt="RustRover" src="https://img.shields.io/badge/-RustRover-000000?logoColor=white&logo=jetbrains">](#) |
| [<img align="left" alt="RustRover" src="https://img.shields.io/badge/-RustRover-feab02?logoColor=black&logo=jetbrains">](#) |
"#
        );
    }
}
